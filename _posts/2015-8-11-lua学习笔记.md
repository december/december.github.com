---
layout: post
category: 技术
tags: lua 脚本 元组
description: 学习写lua语言，理解其面向对象机制和类的实现
---

### 关于lua语言

  * 一种小巧的脚本语言，由C编写而成，具备良好的跨平台特性
  * 由于缺乏强大的库，不适合用来独立开发程序
  * 便于被C代码调用以及调用C。
  * 效率最高的脚本语言

### 语法学习笔记

  * 数组下标从1开始
  * 数组中允许用逗号结尾
  * 大小写敏感，分号可有可无
  * 用nil表示空，没有Null和null
  * 只有nil和false是逻辑的false，包括数字0和空字符串在内的其它变量均为true
  * 循环语句示例：

  		-- 从1加到100
  		sum = 0
  		for i = 1, 100 do
  			sum = sum + i
  		end
  		-- 从1到100的奇数和
  		sum = 0
  		for i = 1, 100, 2 do
  			sum = sum + i
  		end
  		-- 计算大于1000的最小的2的幂
  		sum = 2
  		repeat
  			sum = sum ^ 2
  		until sum > 1000
  		print (sum)
  		-- 从1加到100
  		sum = 0
  		num = 1
  		while(num <= 100)
  		do
  			sum = sum + num
  			num = num + 1
  		end

  * 用elseif关键字表示else if
  * 在使用==和~=进行比较时，只有数字和字符串比较的是值，其余类型都比较引用
  * 没有列表和字典的说法，统一称为table，可以实现列表和字典的功能（即同时具备array和hash的部分）
  * 进行逻辑运算时，对于a or b遵循若a为true返回a、否则返回b；同理，对于a and b遵循若a为false返回a、否则返回b
  * 遍历表的时候需要注意ipairs和pairs的区别：

  		local tb = {[3] = "test2", [6] = "test3", [1] = "test1"}
  		-- 使用ipairs时，从下标为1开始逐一找并执行，直到遇到nil返回0值
  		for k, v in ipairs(tb) do
  			print(k, v)
  		end
  		-- 将只输出1和test1，因为key=2时value就是nil，导致跳出返回

  		-- 使用pairs时将遍历所有key，且在遍历结束后返回nil
  		for k, v in pairs(tb) do
  			print(k, v)
  		end
  		-- 将输出所有的key和value，且顺序与列表中的顺序相同，如本例则为3、6、1


### 一些奇怪的特性

  * 数字只有64位双精度浮点数类型
  * 变量默认为全局变量，除非在前面加关键字local（与python相反）
  * 既没有++也没有+=
  * 可以用...表示函数的缺省参数，例如function a(...)，可以接受任意个参数；在函数内部，可以使用类似super = {...}的方法，通过super[1]、super[2]等访问参数，也可以用这种形式实现多态
  * 用#array来表示数组array的长度（只统计所有下标为整数的元素个数），字符串长度也是这样
  * 在定义某个“类“的成员函数时，function class.function(self, p)与function class:function(p)是等价的，在调用函数时也可这么用
  * 用表实现字典功能的trick：

  		x = 1
  		t = {x=1.1, [x]=1}
  		print(t["x"])      -- get 1.1
  		print(t[1])        -- get 1

### lua的面向对象与类的实现

  * 首先要声明，lua并不是一个面向对象语言，也没有提供面向对象机制，只不过可以用看上去比较trick的方法实现类，而这样做也确实能带来方便。不过也有人认为，lua不是面向对象语言，使用面向对象思想是不科学的。
  * 类是成员变量和方法的集合，任务的关键在于对于一个规定好成员变量和成员函数的类，我们能够创建这个类的一个或多个互相独立的实例，并能对每个实例通过.运算符访问类成员方法、修改实例的成员变量。在这个基础之上，才是继承、多重继承等机制的实现。
  * lua是通过绑定元表的形式来实现类的，具体可以这样描述：首先创建一个表，在这个表中规定好所有的成员变量和成员函数，这个表就是我们的“类”，不妨称这个表为“类表”；需要实例化时，我们新建一个空表（或根据需要构造一个表），通过setmetatable将该表的元表设为刚才的“类表”，然后将该表返回，这样就得到了一个实例
  * 之所以用元表可以实现“类”的效果，是因为在元表中可以重载元方法（metamethod），类似于C++中的重载运算符。在上面的过程中，我们需要指定__index键，这样就能通过.运算符来访问。按照这样的原理可以写出类的new方法，代码如下：

      function Person:new(name)
          local p = {}
          self.__index = self
          setmetatable(p, Person)
          p.name = name
          return p
      end

  * 在lua中使用.运算符时，例如访问a.key，会按以下流程进行：首先找表a是否有名为key的键，若有则返回对应值，否则找表a是否有元表，若有元表则看元表是否有__index键，若有则看__index键对应的值（期望为一个表）是否有名为key的键，若有则返回对应值。
  * 上面的代码创建了“类”Person的new方法，注意到Person本身是一个表，当执行语句p ＝ Person:new(“test”)时，会返回一个元表为Person的表p，当访问p.name时，编译器会首先找p是否有名为name的键，找不到则找p的元表，找到了Person，再看Person是有__index键的，且就是它自己，那么再看Person自己是否有名为name的键，这样就找到了“类”Person的成员变量，而这个成员变量在每个具体实例中是可以不一样的（因为每个具体实例都是不同的表）
  * 理解lua的类的实现的关键，是lua里面的“类”和它的“实例”其实是等价的，都是lua中的表，甚至都是成员相同的表。不同的是作为“类”的表在lua中只作为它的实例的元表，用于通过.运算符访问成员变量和成员方法，自己从来不存实际的东西。
  * 既然所有“类”的实例本身都是一个表，也就可以往这些表里任意增加变量或方法，这样就可以实现面向对象中的继承。


